// Note: this file is encoded in ANSI, in order to encode every byte of the game's data on a 1-byte char.

// These globals are just to inform the minifier what a, b and C-M are. Don't put them in the final file.

//b=document.body;
//a=document.createElement("canvas");
//C=D=E=F=G=H=I=J=K=L=M="";


// DATA (binary)
// =============

// countries 
C = `›2—	aKz)	a9:lR
<:1U	
{q(kJWJZqa\\31[1\\BRJ]ai_1"R:2KiRAYJFiMQE:QCTiLARazQrXCI9!C1Q!1I+	A30©1AJVaÁÃQÇ	BæKë8Qæ5jqc.  GkJŽ5~ÓNÝJ!"R9@2ARqRa
pT@bJPI8J9B)BaQhQqTi|iby)
y#3AXA iÎp0	~KEQF1ZIYIpJ@I;YAOOMP:;!A19XAH/(

0	!a9@9YP{	Xy"I9	Yy	B
y	Y	Z9I{hBzD8PI 
8EYqJYAyRAzQbp	az1)8 *
iyzrqRXL[ipT!YY;hqPAI!(!IZI-9
iQASCAJ*
I.\rQJ6y87(9X9<yN8	OLQMIAIYRADa	3	Q@=I:G$XHLP@H%h$99I1P~‚?‚;phXhqXH@hPAP!1A	8	‡Jh0~ƒTƒn	09 *9"IPIHYiQYQh~W½W½#(YI!B0IZibjaobr	)19!PáB8~ê¾ë¾iR8PI2H)a:KSIYA!41	!!
b")rt}kçÇr ~Œ@Š@pJ
!A~„;‚;8~_¡OˆqiRjqixjhi[q!)!+)GIA2aIQ2YArI0~‘J‘L	x( @PIa~§g©ebB~O»Q¬1*Yqhajajbk!jZYqiz	!8I2#.!*"(~ŒDŒDXHy9(@H(~FiFi	PI0@H@XH~‹=‹;Qy
~‰2‡4	Q)Qh~I‹IˆYhr! ~—_™]pa0rxqO.	x~’+’+Qxpx0 ~ˆ*ˆ*y(!1)x	 	pAKPIQZbTk~’)’)	3 1IhI@Pi[i~Š8…=)0x	rRXpK ~‘R‘Rh:	pIp8r~ŽBŽAPYI0 ~}NƒJXAP@Kh	jXy"~†B…Cp	0I~:}<I0H(@!axXzha{5	0P~q"q"A	Ax
zS~·aµW	qi	Y	8h	 	yHYb19PqaX[Qic86+aAA	9 ~Ì“Ì“X	L@KØ™ Ö™HË’A2=yiyÎˆ!	ixZhK1Õ’)y1I0
PIHhaÛ‡xh@Ý‹yq qX	+AY@1~¥V PsXyq	qy
A01!9AQhI:HA~ Y¢[qQA9H0!	qX~|6|5qR00~š\\š\\i80 ~‰K‰K:X1	0Y{p@haP9	:ˆN@i~JpJpH~ãVãVx"29Zpax[IZi0Xh(hx~šX™ZX~“4“48Jhy~…=…=~KM8a~¢¥ §aq'1ZQ~:n<dkz	!yZHhHh9QF!>1HqyrA B	;1
zyh~†H†H~|Xz\\hZ
()I@~X€X€payI8 9~ŠZŒhXI90 *y	x0ohH~½b¹\`ypI~„8†7@Yh	~üÈüÈbHaI(! @!:pYa~ÚPÚLYxh	@!R~š\\š\\~X¯W²!B0!	xhhiQ~J›J›3@!q! y	hQjxyiXqPB9(~ÖuÖu0!iXqH9Xa2aY (	×€piPxH0~8‹;	0)J@R~zQzQq) I~“GDz	xH(9PHP~¥f¥g8p~¢f£ayhz	aRIhJX2@39(0z~ÊˆÊˆ~@Ž>	xIYA~‹DŒCIh	~•¯—ªIZhAa2kH@Xt		! @ ~ÚRÚR	phR~Ž+Ž+QpaQ 1)0)!iHaQb~×f×fPi~ˆT‡SxhXyXP9!(~˜O“L
yixJPJ@hAXA10XH~–<™;aPHXpQ8Aa@AQB	80	 ~Y¾W¼"yhQ~KPKP~Q{Q{
yHaxPAqhI8*P8H9!x~ŠKŠK~ÌlÍkYpzj[2	!2@ :
~±W¬Vaqh
(Q0HX@HZ~‚J‚J~LO8(xh~”6“4Qi		!2IP~ŽHŽG@Hpy ~x}{!zY@a8H~Ž„Ž†Ah01q{JXA~‰…‹xd@Xip
(81(8~Œ‘Ž†apXaXHX
q	ay	y @)	9+"8H@JXA~}}ƒIQ 8!0	xpa~E|Dzh8~LƒO)1	*P8H1(RaPxiay	~Q¢PšjXxirp!	p)0H)C(@~pupuor~˜V˜VXH~‚‚)8 xpXi~ËyÊz1	ha~UtUt~‹‰‘8x)H)apXaX~OpOp	Bi~‡…‡…‡‰	(H~AuBqIxp@i P~MpNqA8	~CvBs	QXA~š[š[xXhXH~³;¾>BH<Y:ITaxLAQYhzi@Yh	p*yr	) ~JJX0~£\`¡\`q~ÉpÈkyhPqpI 1Q1~›Œ™Œ( 1aixXa:~È…È…2yxhqAÎˆ(A[Hh@~{x}fHjqiKXqp	!	 )@~‹U‹U~•B–BAHyp~´Y¬_
(zPIr[HhyIX0K 0@~I}F|hH(HXA~‰G‰G~uuyxK0!	~FŽDzhPA ~¨‘¨‘¥˜¢˜~¡‡ž8)HB!h	
b~¹€¹€!qhH~˜t›r2@NiHjYsx
i)~š“™ŒX@Hpary@)0:~ÈvÊz1	(1I(8Qpqhphaqx18!0~ t x1PIhJX~–¤“¤iaI:~UqUqUr~ N N8yP~¤N¤N1XHpAyhx~Š—‰£p	8)!P8( IXH1Js~JfJfKgLi~¤d¤d~Áh¿eyqHQ!~WwWw~BqBqa!~Àb¿bpI~“®“®;PIkr!~ÒƒÒƒX~••b~‹yŒhXqiYhrXxh	!0*~Ÿ›Ÿ› œ~ŸzŸzPq~BwBwIy~œtŸx:1Yip~œ}ž„P	HA0@ H(AZahXi ~ÿ¥ÿ¥0Xxÿ¢X~‡Š‡‹ 	0	XiX@a9~uwuw	@~ L L0BIh~‚‚+HPia~UyUy~w|{€ 2JYyp~uywxpQ1~ûˆûˆü‹û†Ž‘‡™~µJ²L		YPHXJ~’01
x)P8PX8~”µ”µxXH~yx€yqH~ˆBˆB~™ž˜ž )qhxphH0~µ„µ„µŠ´‡~ú€ú€÷}ú}÷zôz~up}fHjqiKX0I(2
 )	(~©§©§~ð€ð€íƒì€ë}ä|â}~ÌAÓ>a
xT@bJPI@J:A)B	)	~ŽJŽL0x~˜¯˜± )8 +YP@XrX8(@Qpiaih~ÄnÆ}!3XH)9"ybpXPhqip~«‹«4
p@PIoAP2~÷‹÷‹~DyDz9aq~‚wƒy	!)1IRYIqaI~†}ƒy	 qd8PhQ9@~ªh¨j!py\\Q1~ààh0~é˜é˜9YA+yqyê’iIï”@(~–•ŽpQ~TqTq~VvVv~UwUw~žž~…Š…Š†ˆ~wx0Q~ò˜ò˜x0ó™Pó˜8ñ•x@ð–~—ƒ“{x
jXhYI0P;!~Z‚Xaz )~šYšYX!HPJi~±Q±Q8 	Q
yR HXP~Ù—Ù—	Q~‚)8~©©§¥~U{U{p ~ªRªR@Q20H!|HZH~ÿ—ÿ—ý“~˜Š˜ŠYH("	q~²L²LPH2XHBIj(ppy 8 
@~ø¤ø¤÷ h0ø¥~• “¥A8)!p9)	yjQp@Y~©©\r™~	¥	¥
§~—°—°xP(`.split("~"),

// us states 
D = `h‘q~,<0G!@1<XAI/+MAKBWQLRZIbzraT[8Qi0		zqzML
KJ~7W6[+MhI~:k?t!-Mk~GrDom
(
,~ebf]lBJ!
!~\\}\\}Y9(
yra:~WiWo:#
ak~]i[k*iZ~hghg Ph~^v[t[1~O}G{{zh1+AK)JkJ~ckbj	j~\`r_tK!qR~AgBdJm,I~bnbjyiN~^m]maQ~ch_i)qQI~hchcIh
~gffea ~Yw[y2Il(	~9n:dKjyt	)?~HjDp,N~[v[y2qa0J~[_Ye$R:qzk~LYP[N+~AYISlMR5~PgPbNi	i~AwDpmIB*!~TtRw*xbJ~hah]jH~ehek!AqPy~dkdki!~OsRpOh
i~>aBdL/u~7^6d,l~Zi[ejYH+~SeQg!AL~QkKjjN~L^I[k+~[m[kYRp0~YrVqYL~VVB+	b	x~i_hc*jx~g\`f]	bP~S]Pa.	Rjy~VyVs	lP0I~WaXc"H:Ijy~TmRq+8azh~HdIf,MXk`.split("~"),

// territories 
E=`UUIzrIzasz$!1AA
MBONR~}U~Us~Ñj~çw~Gn~Vu~Tp~ ¡£¡¥¤~}¡~Tp~¨¨~÷ªP9~RpHP@x~š›ž~\\ƒaH)~=~´’´•~¡œ~YC~Tp~Ÿ~|&~S[~‹Š‰‚	rb~³ÖXH p~Sp~Sq~OxPx~Ox~)~gà@ymãnænèmê~Qy~ƒà~Åœ~Px~Ë™~tk
 )	 JYh~WÚYVÛ h~µÝ~}5~>~Ðl~èr~Tr~÷´~%¯&®)®~{X~—~Lÿy#[||ÿ~Nk~ŒDKIA`.split("~"),

// places
F=`HacªÓN—]‚?ˆG‚K€9LMÓN—]‚?’QŠK›1„;‚E€?ˆF??1UƒG}TLM-XMM‚?KQˆF/S~NMLŠKˆGN§fŠK+?˜d*R§f*R”P„;üÀ’›1•¡âW·\`ŠK˜hÉ…3FIH·\`kŽ;€:8FKQŽ»ë»‚K‹M„;4±GdCJ‰ECJŠ1€9•KMŸŽ»®XÊw´Xˆ?µ[š\\Ó–Bl’D•LÝ­Š8“S6OáVš]r8Š`.match(/.{2}/g),

// lakes
G=`ECQ0K~…D~CFbpI~P¢8~—Ša	)~(
QxI~™˜qi1~3$R8Y~Dyp~}/~Öt~Ê: paXQ~KGR
~Ös~EDxi@~——9)~FLX~<:9iqX~–'yP~µF(
XI~™"iy(8(~)I~Îe~.:~+R~,=`.split("~"),

// streams 
H=`_ŒQ@Q@TBRAbqiypMYAiqW[pQkzY9ZŽ[qai\\haxiapaS0JAH9~—\\iXziZqqYhqaHhqi˜txhr ~‰’)	zjpbhŒŽhq~…„!0@(;1HZQaP…„!0	p~B	php~š¦1@JYH9(0 ~±h(0(! ~A_9!(9"9A( ~0\\0 0~(By	()1y~W¼"	y~×\\@HZ@Q0IYIiH8@1(:HP~ÕRQaJ0 ( APbXIXpxI8@~Ñj8J0HQ(~¥B!1
*~•K9K@H*IPAQ@(0~„8ipap~‡5hy~ƒ8ha~„I )~=yx~Œ´
y	~urypaq~0@2X~Švxhyq~uw~xa	9~}ƒ0!@~Ž1HX~W¼@(#	"
X±!2!@~'"	yq{~g™AQYpbiH~ŸŠ0*@~˜°2IX~<eA(9XA2"@~_ŒYqxXbiaX~V}Tay	~=a2@~ {	zq~Lzhqai~(@	*1~cŽYiX~OA[Q~V0BH0~Xaxh~Ûax[riQKRAYR[pÜ"	iZLZ~ä7h\\J;1JbP~Ì}910H1@ 0 8(3A~»q	qXyazrybi	¿yaqYÂ-xayj~±HaiyqZh±&ybZbP±.	Y}h~Âj9(0~Æv)1+2BH~£^B;H8~ªFr{~Àk2K9@(~¬Cyi~Äs*#~óiIUzaHQ8h@~£^9A)9~ëQiSqY~¤O9AIh~»s9@I@~ºt@PB~´i	~Ìm9A~þ!AP ~£E;"8 9Q9BaHX9~—D0B+~›DA3~§biyYq~–D:J~zQ	~Ž5i	pX~‘/y	~ã¾	y	xå¼!	~çQHx`.split("~"),

// deserts 
I=`ws3wWOOO~0X)zjQ~šav[U3~ÉN#[Ta~à¹DR:b~ß¯"c~M¡t\\*!1 ~ \\;Zk~ß°JG
z~Œ³2 4{kr~4Zui;B:3~ªjcB~Qß9)1Elcs~ªR:|R~2_0Iq;*|i~¬MrM~¶NjT~µi;j	~Ú®[:~«d!:K~­ds~0WB)~§ViI~ª_2
r`.split("~"),

// volcanoes
J=`‹R‹L¨¨Vus!*Bm‹OAtÖsù¥×v÷ Ï”wAuöÿÝZ•‹ì‘nK†Ë‘Ô–L€`.match(/.{2}/g),

// mountains
K=`½\`¶T¼\`ãU›Ž…D;oN¸WùÌ¾a¾a¾a»\`¼\`·V¸V¸W½a¿b"pNÓÏWŸH†D,R2FQ©‰C~0+@ÓÓ^º\\/7`.match(/.{2}/g),

// forests 
L=`\\†COVn;$~Ë‘A2:ry~\r

|c{{,}RK^BI;OFOG<LET6‹c
[<OMREOWOK[ODMWT4C~DH!xiCE0Kk
~-W:2)jz~‹œ*ubUD4dJ~‡Œ"1i
j[KCY~Ó‚Y~ÁjR!
p~è¦1Zr~Æh!yi~7	yYA~†A!xi~©VI[}*~@q	b9~*zq!<~EtY~h’iYciYaSj[:#y5~P³Zkbi#*`.split("~"),

// seas
M=`D/ 3?}F#I)L$AM7o$o:m/i;T#R&L.wP\r$:+.G>=C$D'd?gImNADR2W<N:m\`A
"#uo,f7j?kBl?kJmIpKycl,j(qP%* GM"F)I*F/J'I*Q<U4_;V	ky}	4}}}q\`p^,`.match(/[^]{3}/g);


// ONLOAD
// ======

// This onload function makes all the var names minifiable and waits for the fonts to load.
onload = function(){

// GLOBALS
// =======

// DATA
// ====

// by order of drawing:

// 0: seas
// 1: countries
// 2: us states
// 3: territories
// 4: deserts
// 5: forests
// 6: lakes
// 7: streams
// 8: capitals
// 9: us capitals
// 10: volcanoes
// 11: mountains
// 12: places
// 13: flags

var
datasets = [

  // 0: seas
  [
    "SEA",                  // dataset name
    
    // names
    "Mediterranean seaGulf of mexicoEnglish channelBering seaAdriatic seaAegean seaBlack seaNorth seaRed seaSea of japanPhilippine seaEast china seaSouth china seaAral seaCaspian seaDead seaCoral seaGulf of alaskaCaribbean seaSargasso seaBaltic seaIrish seaCeltic seaLigurian seaTyrrhenian seaGulf of thailandJava seaTimor seaGulf of guineaPersian gulfArabian seaBarents seaGreenland seaGreat australian bightNorwegian seaHudson bayJames baySea of okhotskSeto inland seaBeibu gulfSulu seaCelebes seaBohol seaFlores seaBanda seaArafura seaTasman seaYellow seaBohai seaGulf of carpentariaBaffin bayGulf of st lawrenceGulf of bothniaSea of azovIonian seaMirtoon seaGulf of sidraMarmara seaSea of creteGulf of adenGulf of omanBay of bengalKara seaBeaufort seaAmundsen gulfChukchi seaLaptev seaEast siberian seaAmundsen seaWeddell seaRoss seaGulf st vincentSpencer gulfSalton sea".split(/(?=[A-Z])/),

    M,                      // center and radius for each sea (2b + 1b)
    [...Array(74).keys()],  // questions not asked yet (it's an array from 0 to N = 74)
    3,                      // how many bytes represent each item
    1,                      // fill color (0 = none, 1 = transparent = highlightable)
    0,                      // stroke color (0 = none)
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    16,                     // diststep
  ],

  // 1: countries
  [
    "COUNTRY",              // dataset name
    
    // names
    A="RuRussiaMoscowCnChinaBeijingCaCanadaOttawaFrFranceParisDzAlgeriaAlgiersArArgentinaBuenos airesAuAustraliaCanberraAtAustriaViennaBeBelgiumBrusselsBrBrazilBrasiliaBgBulgariaSofiaAeUnited arab emiratesAbu dhabiClChileSantiagoHrCroatiaZagrebCuCubaHavanaCzCzech republicPragueDkDenmarkCopenhagenEcEcuadorQuitoEgEgyptCairoEeEstoniaTallinnNoNorwayOsloFiFinlandHelsinkiDeGermanyBerlinGrGreeceAthensHuHungaryBudapestEsSpainMadridChSwitzerlandBerneGbUnited kingdomLondonIsIcelandReykjavikInIndiaNew delhiIdIndonesiaJakartaIrIranTehranIqIraqBaghdadIeIrelandDublinIlIsraelJerusalemItItalyRomeJmJamaicaKingstonJpJapanTokyoLbLebanonBeirutLtLithuaniaVilniusLuLuxembourgLuxembourgMkMacedoniaSkopjeMgMadagascarAntananarivoMxMexicoMexico cityMcMonacoMonacoMaMoroccoRabatGyGuyanaGeorgetownLyLibyaTripoliNpNepalKathmanduNlNetherlandsAmsterdamNzNew zealandWellingtonKpNorth koreaPyongyangPsPalestineJerusalemPyParaguayAsuncionPePeruLimaPhPhilippinesManilaPlPolandWarsawPtPortugalLisbonRoRomaniaBucharestQaQatarDohaSaSaudi arabiaRiyadhSgSingaporeSingaporeSkSlovakiaBratislavaSiSloveniaLjubljanaZaSouth africaPretoriaKrSouth koreaSeoulSeSwedenStockholmTwTaiwanTaipeiTnTunisiaTunisTrTurkeyAnkaraUaUkraineKievUyUruguayMontevideoUsUsaWashington dcVeVenezuelaCaracasVaVatican cityVatican cityVnVietnamHanoiAfAfghanistanKabulAdAndorraAndorra la vellaAlAlbaniaTiranaByBelarusMinskBaBosnia & herzegovinaSarajevoBfBurkina fasoOuagadougouCfCentral african republicBanguiCmCameroonYaoundeCdDrcongoKinshasaCiCote d'ivoireYamoussoukroCrCosta ricaSan joseCoColombiaSanta fe de bogotaBoBoliviaLa pazCvCape verdePraiaCyCyprusNicosiaBjBeninPorto novoKhCambodiaPhnom penhDmDominicaRoseauCgCongoBrazzavilleDoDominican republicSanto domingoGqEquatorial guineaMalaboGtGuatemalaGuatemala cityHtHaitiPort-au-princeHnHondurasTegucigalpaJoJordanAmmanKzKazakhstanAstanaXkKosovoPristinaKwKuwaitKuwait cityLaLaosVientianeKeKenyaNairobiMyMalaysiaKuala lumpurMlMaliBamakoMtMaltaVallettaMdMoldovaChisinauPkPakistanIslamabadPaPanamaPanama citySmSan marinoSan marinoSnSenegalDakarRsSerbiaBelgradeScSeychellesVictoriaSoSomaliaMogadishuLkSri lankaColomboSdSudanKhartoumTzTanzaniaDodomaThThailandBangkokYeYemenSan'aZwZimbabweHarareAgAntigua & barbudaSt john'sAmArmeniaYerevanAzAzerbaijanBakuAoAngolaLuandaBsThe bahamasNassauBhBahrainManamaBdBangladeshDhakaBbBarbadosBridgetownBzBelizeBelmopanBtBhutanThimphuBwBotswanaGaboroneBnBruneiBandar seri begawanBiBurundiBujumburaTdChadN'djamenaKmComorosMoroniDjDjiboutiDjiboutiSvEl salvadorSan salvadorErEritreaAsmaraEtEthiopiaAddis ababaFjFijiSuvaGaGabonLibrevilleGmGambiaBanjulGeGeorgiaTbilisiGhGhanaAccraGdGrenadaSt george'sGnGuineaConakryGwGuinea-bissauBissauKiKiribatiTarawaKgKyrgyzstanBishkekLvLatviaRigaLsLesothoMaseruLrLiberiaMonroviaLiLiechtensteinVaduzMwMalawiLilongweMvMaldivesMaleMhMarshall islandsMajuroMrMauritaniaNouakchottMuMauritiusPort louisFmMicronesiaPalikirMnMongoliaUlan batorMeMontenegroPodgoricaMzMozambiqueMaputoMmMyanmarNaypyidawNaNamibiaWindhoekNrNauruYarenNiNicaraguaManaguaNeNigerNiameyNgNigeriaAbujaOmOmanMuscatPwPalauMelekeokPgPapua new guineaPort moresbyRwRwandaKigaliKnSt kitts & nevisBasseterreLcSt luciaCastriesVcSt vincent & the grenadinesKingstownWsSamoaApiaStSao tome & principleSao tomeSlSierra leoneFreetownSbSolomon islandsHoniaraSsSouth sudanJubaSrSurinameParamariboSySyriaDamascusTjTajikistanDushanbeTlTimor-lesteDiliTgTogoLomeToTongaNuku'alofaTtTrinidad & tobagoPort of spainTmTurkmenistanAshgabatTvTuvaluFunafutiUgUgandaKampalaUzUzbekistanTashkentVuVanuatuPort vilaZmZambiaLusakaCkCook islandsAvaruaNuNiueAlofiSzSwazilandMbabane".split(/(?=[A-Z])/),
    
    C,                      // polygons for each country (array of strings, 2b for capital + 2b + 1b per point)
    [...Array(199).keys()], // questions not asked yet (it's an array from 0 to N = 199)
    0,                      // how many bytes represent each item (0 = variable)
    "#080",                 // fill color
    "#000",                 // stroke color
    2,                      // start byte for the path
    3,                      // name group size
    1,                      // position in name group
    8,                      // diststep
  ],

  // 2: us states
  [
    "US STATE",             // dataset name
    
    // names
    B="HawaiiHonoluluAlaskaJuneauWashingtonOlympiaNevadaCarson cityNew mexicoSanta feNew yorkAlbanyFloridaTallahasseeIllinoisSpringfieldOhioColumbusRhode islandProvidenceSouth carolinaColumbiaTexasAustinMarylandAnnapolisNorth carolinaRaleighUtahSalt lake cityVirginiaRichmondWest virginiaCharlestonPennsylvaniaHarrisburgMassachusettsBostonConnecticutHartfordAlabamaMontgomeryCaliforniaSacramentoColoradoDenverGeorgiaAtlantaMichiganLansingNorth dakotaBismarckMontanaHelenaNebraskaLincolnArizonaPhoenixArkansasLittle rockNew hampshireConcordNew jerseyTrentonDelawareDoverOklahomaOklahoma cityIdahoBoiseOregonSalemIndianaIndianapolisIowaDes moinesKansasTopekaSouth dakotaPierreKentuckyFrankfortTennesseeNashvilleLouisianaBaton rougeMaineAugustaVermontMontpelierMinnesotaSt paulMississippiJacksonWisconsinMadisonMissouriJefferson cityWyomingCheyenne".split(/(?=[A-Z])/),
    
    D,                      // polygons for each country (array of strings, 2b for capital + 2b + 1b per point)
    [...Array(50).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    "#080",                 // fill color
    "#000",                 // stroke color
    2,                      // start byte for the path
    2,                      // name group size
    0,                      // position in name group
    6,                      // diststep
  ],

  // 3: territories
  [
    "TERRITORY",            // dataset name
    
    // names
    "GreenlandGibraltarGuadeloupeHong kongGuamCayman islandsMartiniqueSt martinFrench polynesiaSt helenaSt barthelemyReunionNew caledoniaPuerto ricoWallis & futunaFrench guianaGuernseyBritish indian ocean territoryMayotteSt pierre & miquelonAnguillaAmerican samoaFaroe islandsBermudaUs minor outlying islandsFrench southern territoriesBritish virgin islandsUs virgin islandsNetherlands antillesArubaAland islandsSouth georgiaBonaireBouvet islandCocos islandsCuracaoChristmas islandWestern saharaFalkland islandsHeard & mcdonald islandsIsle of manJerseyMacauNorthern marianasMontserratNorfolk islandPitcairn islandsJan mayen islandTokelauAntarticaTurks & caicos islandsSvalbard".split(/(?=[A-Z])/),

    E,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(52).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    "#080",                 // fill color
    "#000",                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 4: deserts
  [
    "DESERT",               // dataset name
    
    // names
    "SaharaColorado plateauArabian desertGobiGreat victoriaSimpsonAtacamaSyrian desertGreat sandy desertNamibChihuahuan desertKalahariPatagonian desertKarakumSonoranKyzylkumTaklamakanTharGibsonDasht-e margoRegistanMojaveDasht-e kavirDasht-e loot".split(/(?=[A-Z])/),

    I,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(24).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    "rgba(255,255,255,.2)", // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 5: forests
  [
    "FOREST",               // dataset name
    
    // names
    "Amazon rainforestSumatra rainforestTaigaGreat lakes st lawrenceSierra nevadaMiombo woodlandsCongo basin forestKinabaluThe sundarbansDaintree rainforestXishuangbannaBialowieza primeval forestThe black forestVirgin komi forestsLacandon jungleTongassBosawas biosphere reserveAtlantic forestValdivian rainforest".split(/(?=[A-Z])/),

    L,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(19).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    "rgba(0,0,0,.1)",       // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 6: lakes
  [
    "LAKE",                 // dataset name
    
    // names
    "SuperiorLemanMichiganTiticacaVictoriaGreat bear lakeMalawiGreat slave lakeNicaraguaLoch nessTaal lakeBaikalOntarioPinatuboHuronTanganyikaErieWinnipegLadogaBalkhashOnegaCrater lakeReed flute caveEmerald lakeMirror lakeSpotted lake".split(/(?=[A-Z])/),

    G,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(26).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    "#0af",                 // fill color
    "#000",                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 7: streams
  [
    "STREAM",               // dataset name
    
    // names
    "AmazoneNileCongoNigerLoireZambezeIndusMississippiColoradoColumbiaUruguayYangtzeYellow riverXiUralDanubeRhinElbeMeuseRhoneSeineOrangeSenegalVoltaChariGambiaDraaBandamaTanaParanaYukonSao franciscoJubbaLimpopoRio grandeTocantinsOrinocoBrazosMackenzieMagdalenaFraserParnaibaSaint-laurentRio negroEssequiboLenaAmourMekongIenisseiObBrahmapoutreSalouenEuphratesAmou-dariaGangeSyr-dariaIrrawaddyKolymaTigrisIndiguirkaKouraGodavariKrishnaNarmadaRed riverAnadyrVolgaDnieperDonPechoraDniestrTagusVistuleDaugavaMurraySepik".split(/(?=[A-Z])/),

    H,                      // polygons for each country (array of strings, 2b + 1b per point)
    [...Array(76).keys()],  // questions not asked yet
    0,                      // how many bytes represent each item
    0,                      // fill color
    "#0df",                 // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 8: capitals            
  [                         
    "CAPITAL",              // dataset name
    A,                      // names
    C,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(199).keys()], // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    3,                      // name group size
    2,                      // position in name group
    8,                      // diststep
  ],                        
  
  // 9: us capitals
  [
    "US CAPITAL",           // dataset name
    B,                      // names
    D,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(50).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    2,                      // name group size
    1,                      // position in name group
    6,                      // diststep
  ],
  

  // 10: volcanoes
  [
    "VOLCANO",              // dataset name
    
    // names
    "EtnaVesuviusPiton de la fournaiseMount peleeEyjafjallajokullSt helensKilaueaStromboliSanta mariaPinatuboYasurTaalAmbrymMerapiErta alePacayaErebusSakurajimaNyiragongoUlawunMauna loaGalerasKrakatoaTamboraNevado del ruiz".split(/(?=[A-Z])/),

    J,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(25).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 11: mountains
  [
    "MOUNTAIN",             // dataset name
    
    // names
    "Mount everestK2AnnapurnaFujiKilimanjaroMont blancPopocatepetlOlympusBroad peakCookLhotseMakaluCho oyuDhaulagiriManasluNanga parbatGasherbrum iGasherbrum iiShishapangmaKangchenjungaDenaliKirkjufellFitz royHuaElbrusMatterhornEl capitanGrand tetonLicancaburTre cime de lavaredoBen nevisRainierKinabaluHuangKailashBanff".split(/(?=[A-Z])/),

    K,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(36).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],

  // 12: places
  [
    "PLACE",                // dataset name
    
    // names
    "Cape canaveralChrist the redeemerGreat chinese wallGreat sphinxEiffel towerTower of pisaSagrada familiaBig benStatue of libertyForbidden cityThe pyramids of gizaThe palace of versaillesAcropolisTrevi fountainKremlinAtomiumLascaux cavesMont st michelPiazza san marcoWashington dcGrand canyonMillau bridgeRock of gibraltarEmpire state buildingHollywood signTimes squareLouvre museumWhite houseFlorence cathedralLas vegasMadrid palaceCentral parkSistine chapelPiazza del campoMachu picchuBurj al arab hotelSt peter basilicaCapitol hillLuxor templeGolden gate bridgeBurj khalifaAlcatrazEphesusManneken pisMount eden craterNorth capeSt basil cathedralVictoria fallsGreat buddha of kamakuraLotus templeColosseumAbu simbelPetronas twin towersYellowstoneNiagara fallsTaj mahalMeccaAuschwitzStonehengeMount rushmorePentagonCape of good hopeOpera houseParc guellPompeiiWaterlooEaster islandEvergladesCloud gateRialto bridgeWillis towerLittle mermaidTower bridgeBlue mosqueNevado mismiTable mountainMinaret of jamAngkor watFaisal mosqueNeuschwanstein castleGolden temple of amritsarAl aqsa mosqueTemple of besakihChichen itzaBran castleHagia sophiaUluruBrandenburg gateBlue domed churchCheyenne mountainKiyomizu-deraPetraTombouctouKultury i nauki palaceNull island".split(/(?=[A-Z])/),
    
    F,                      // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(95).keys()],  // questions not asked yet
    2,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    0,                      // start byte for the path
    1,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ],
  
  // 13: flags
  [
    "COUNTRY",              // dataset name (not "flags" because the game will say "find this country:")
    A,                      // names
    C,              // polygons for each country (array of strings, the first 2b represent the capital)
    [...Array(199).keys()], // questions not asked yet
    0,                      // how many bytes represent each item
    0,                      // fill color
    0,                      // stroke color
    2,                      // start byte for the path
    3,                      // name group size
    0,                      // position in name group
    8,                      // diststep
  ]
],

c = a.getContext("2d"),                 // canvas context2d
state = 0,                              // 0 = title screen
question = 0,                           // current question number
questions = 1123,                       // total questions (chosen by player)
mode = 0,                               // 0 = highest score / 1 = "least errors"
error = 0,                              // current error
errorsum = 0,                           // error sum (in mode 1)
flags = 1,                              // enable flags
item = 0,                               // current item index
items = 0,                              // current list of questions
itemname = "",                          // current item name
itemindex = 0,                          // current item index
nameparts = 0,                          // current item name parts
dataset = 0,                            // current dataset
lastdataset = 3,                        // previous dataset
ds = 0,                                 // dataset being drawn
scores = [],                            // scores for each question
score = 0,                              // final score
time = 0,                               // time to answer each question
interval = 0,                           // interval to load the flags

// FUNCTIONS
// =========


// Draw a screen
draw = function(){

  // Reset canvas, except for feedback state
  a.width ^= 0;
  
  // Black background except on map and feedback
  if(state != 3 && state != 4){
    c.fillStyle = "#123";
    c.fillRect(0, 0, 1024, 1024);
  }

  // Title screen (0)
  if(state == 0){
    
    // Stars
    c.fillStyle = "#fff";
    for(i = 500; i--;) c.beginPath(), c.arc(Math.random() * 1020, Math.random() * 600, Math.random() + .5, 0, 7), c.fill(); 

    // 2
    c.font = "600px i";
    c.fillStyle = "#07d";
    c.fillText(2, 660, 550);
    
    // Emoji
    c.font = "260px i";
    c.fillText("\u{1f30d}", 195, 410);
    
    c.font = "50px i";
    c.fillText("\u{1f312}", 700, 220);
    
    // GE ... QUIZ
    c.fillStyle = "#fff";
    c.font = "200px i";
    c.fillText("GE       QUIZ", 50, 405);
    c.lineWidth = 6;
    c.strokeText("GE       QUIZ", 50, 405);
    
    // PLAY
    c.fillStyle = "#000";
    c.font = "70px i";
    c.fillText("\u25b8PLAY\u25c2", 685, 540);
  }
  
  // Flags on Windows and Linux (10)
  else if(state == 10){
  
    // Flag emoji polyfill
    b.style.fontFamily = "f,i";
  
    c.fillStyle = "#fff";
    c.font = "110px i,f";
    
    c.fillText("Enable flags?", 200, 150);
    c.fillText("\u25b8OK       \u25b8no", 210, 500);

    c.font = "110px f";
    c.fillText("\u{1f1fa}\u{1f1f8}", 450, 360);
    
    c.font = "40px i";
    c.fillText("Click OK when you see a flag below:", 220, 220);
    
    interval = setInterval(function(){
      if(state == 10){
        draw();
      }
    }, 100);
    
  }
  
  // Menu (1)
  else if(state == 1){
  
    if(interval){
      clearInterval(interval);
    }
    
    c.fillStyle = "#fff";
    c.font = "110px i";
    
    c.fillText("Game mode", 60, 150);
    
    c.font = "70px i,f";
    
    c.fillText("\u25b8High score", 50, 280);
    c.fillText("\u25b8Endless", 50, 460);
    
    c.font = "35px i,f";
    
    c.fillText("Answer 25 to 1000 questions", 110, 330);
    c.fillText("Play until you reach 50,000km of errors", 110, 510);

  }
  
  // High score submenu (11)
  else if(state == 11){
  
    c.fillStyle = "#fff";
    c.font = "110px i,f";
    
    c.fillText("Highest score", 60, 150);
    
    c.font = "60px i,f";
    
    c.fillText("\u25b825 questions", 50, 270);
    c.fillText("\u25b850 questions", 50, 400);
    c.fillText("\u25b8100 questions", 50, 530);
    
    c.fillText("\u25b8250 questions", 550, 270);
    c.fillText("\u25b8500 questions", 550, 400);
    c.fillText("\u25b81000 questions", 530, 530);
  }
  
  // Choose a question (2)
  else if(state == 2){
  
    // Pick a dataset
    // --------------
      
    // First 3 questions: country (1), capital (8), place (12)
    if(question < 3){
      dataset = [1,8,12][question];
    }
    
    
    // For all the other questions, the dataset is picked randomly
    else {
      dataset = lastdataset;
      
      // Try 999 times to pick another dataset than the previous one, then abandon and take the same
      for(i = 0; i < 999; i++){
      
        var random = Math.random();
      
        // 30% chance to choose country, capital or place (10% each)
        if(random < .1) dataset = 1;
        else if(random < .2) dataset = 8;
        else if(random < .3) dataset = 12;
        
        // 70% chance to choose one of the 11 other datasets (or 10 if flags are disabled)
        else {
          
          // Flags: 70% / 11 = 6.4% for datasets 0 and 4-11
          // No flags: 70% / 10 = 7% for datasets 0 and 4-10
          dataset = (4 + (~~((random - .3) / (flags ? .064 : .07)))) % (flags ? 14 : 13);
        }

        // If we found a new dataset not empty: keep it
        // Also, avoid US capitals before question 20
        if(dataset != lastdataset && datasets[dataset][3].length > 0 && !(question < 20 && dataset == 9)){
          break;
        }
        
        // Else, take the last one (it is for sure not empty but it was avoided until now)
        dataset = lastdataset;
      }
      
      // Save this dataset
      lastdataset = dataset;
    }
    
    //console.log(dataset);
    //dataset = 2;
    
    items = datasets[dataset][3];
    
    //console.log(dataset, items);
    //console.log(J);
    
    // If no question left or 50000km attained in mode 1: go to score screen
    if(question >= questions || items.length == 0 || errorsum > 50000){
      state = 5;
      draw();
      return;
    }
    
    // Pick a question
    // ---------------
    
    // Pick one of the first 10 available answers
    // This ensures a progressive difficulty.
    // For the first 3 questions, pick between the first 30 (they're all easy, and it makes the games less repetitive)
    item = ~~(Math.random() * Math.min(question < 3 ? 30 : 10, items.length)); 
    //console.log(item);
    
    itemindex = items[item];
    
    // Save item's name
    itemname = 
      datasets[dataset][1] // names
      [datasets[dataset][8] * itemindex + datasets[dataset][9]] // name index index
      .toUpperCase();

    // Remove that question from the array of available questions
    items.splice(item, 1);
    
    // Display everything
    // ------------------
    
    c.fillStyle = "#fff";
    c.textAlign = "left";
    
    c.font = "40px i,f";
    c.fillText("Question " + (question + 1) + (mode == 0 ? ("/" + questions) : ""), 30, 50);
    
    //console.log(mode);
    if(mode == 1 && errorsum > 0){
      c.fillText("Error: " + errorsum + "km", 30, 100);
    }
    
    c.textAlign = "center";
    c.font = "70px i,f";
    
    // Find this ... :
    c.fillText("FIND THIS " + datasets[dataset][0] + ":", 512, 280);

    // Arrow
    c.fillText("\u25b8", 970, 560);
    
    // Question
    
    // Flag
    if(dataset == 13){
      c.font = "200px i,f";
      c.fillText(itemname = String.fromCodePoint(0x1F1E6 + itemname.charCodeAt(0) - 65) + String.fromCodePoint(0x1F1E6 + itemname.charCodeAt(1) - 65), 512, 470);
    }
    
    // Name
    else {
      c.font = "100px i,f";
      if(itemname.length > 15){
        nameparts = itemname.match(/.{1,15}( |$)/g);
      }
      else {
        nameparts = [itemname];
      }
      
      c.fillText(nameparts[0], 512, 400);
      if(nameparts[1]){
        c.fillText(nameparts[1], 512, 500);
      }
    }
  }
  
  // Map (3)
  else if(state == 3){
  
    // Trace datasets 1-7 (scaled if US state or US capital)
    us = dataset == 2 || dataset == 9;
    
    for(ds = 1; ds < 8; ds++){
    
      // extra x offset for us items
      extraxoffset = ds == 2 ? 0 : -1.5;
      
      us ? trace(ds, 3.9, -250 + extraxoffset * 3.9, -350) :  trace(ds, 1, -4 + extraxoffset, 0);
    }
    
    // Repeat the question
    c.fillStyle = "#000";
    c.fillRect(0,0,1024,60);
    
    c.fillStyle = "#fff";
    c.font = "40px i,f";
    c.fillText(datasets[dataset][0] + ": " + itemname, 10, 45);
    
  }
  
  // Feedback (4)
  else if(state == 4){
    
    // If the item is a sea, trace it highlighted in yellow before the rest of the map
    if(dataset == 0){
      tmp = tracesea(M[itemindex]);
    }
    
    // Trace the map
    for(ds = 1; ds < 8; ds++){
      // extra x offset for us items
      extraxoffset = ds == 2 ? 0 : -1.5;
      
      us ? trace(ds, 3.9, -250 + extraxoffset * 3.9, -350) :  trace(ds, 1, -4 + extraxoffset, 0);
    }
    
    // If the item is a polygon, trace it highlighted on top of the map
    if(dataset != 0){
    
      //console.log(items, item);
      extraxoffset = dataset == 2 ? -4 : -5.5;
    
      tmp = traceitem(
        datasets[dataset][2][itemindex],// polygon
        datasets[dataset][7],           // start byte
        datasets[dataset][4],           // bytes to draw
        datasets[dataset][10],          // diststep
        dataset == 7 ? 0 : "#ff0",      // fill (except for streams)
        "#db0",                         // stroke
        us ? 3.9 : 1,                   // scale
        us ? -250 + extraxoffset 
           : extraxoffset,              // x offset
        us ? -350 : 0,                  // y offset
        5,                              // line width
      );
      
    }
    
    // Trace the error distance (if any)
    if(tmp[0] > 4){
      c.beginPath();
      c.fillStyle = "red";
      c.arc(X,Y,10,0,7);
      c.fill();
      c.beginPath();
      c.setLineDash([15, 5]);
      c.strokeStyle = "red";
      c.lineWidth = 5;
      c.moveTo(X,Y);
      c.lineTo(tmp[1],tmp[2]);
      
      c.moveTo(X-1020,Y);
      c.lineTo(tmp[1]-1020,tmp[2]);
      
      c.moveTo(X+1020,Y);
      c.lineTo(tmp[1]+1020,tmp[2]);
      
      
      c.stroke();
      c.setLineDash([]);
    }
    
    c.fillStyle = "#000";
    c.font = "110px i,f";
    c.strokeStyle = "#fff";
    c.lineWidth = 2;
  
    // Perfect
    if(tmp[0] < 5){
      c.fillText("Perfect!", 350, 550);
      c.strokeText("Perfect!", 350, 550);
    }
    
    // Error
    else{
    
      // Scale: 100px = 3000km
      // 1px = 30km
      
      //error = ~~((tmp[0] * 30)/100) * 100;
      
      error = ~~(tmp[0] * .3) * 100;
      if(mode == 1){
        errorsum += error;
      }
      
      //errortxt = error > 999 ? (error/1000).toFixed(3) : error;
      
      c.fillText(error + "km away!", 200, 550);
      c.strokeText(error + "km away!", 200, 550);
    }
    
    // Arrow
    c.fillText("\u25b8", 900, 560);
    c.strokeText("\u25b8", 900, 560);
    
    // Repeat the question + the country if the question was a capital or a flag
    c.fillStyle = "#000";
    c.fillRect(0,0,1024,60);
    
    c.fillStyle = "#fff";
    c.font = "40px i,f";
    c.fillText(datasets[dataset][0] + ": " + itemname + (dataset == 8 || dataset == 13 ? " (" + A[itemindex * 3 + 1] + ")" : dataset == 9 ? " (" + B[itemindex * 2] + ")" : "").toUpperCase(), 10, 45);
    
    // Score for each question: 100 - time (in seconds) - (error in km) / 50
    
    scores[question] = Math.max(0, 100 - time - ~~(error / 50));
    
    //console.log(scores);
    
  }
  
  // Score
  else if(state == 5){
    
    // Max score
    if(mode == 0){
      score = ~~(scores.reduce((a,b) => a+b) / scores.length) + "%";
    }
    
    // Min errors
    else {
      score = question;
    }
    
    c.fillStyle = "#fff";
    c.font = "110px i,f";
    
    c.fillText("Score: " + score, 280, 250);
    

    c.font = "40px i,f";
    c.fillText("\u25b8share", 400, 400);
    c.fillText("\u25b8replay", 400, 500);

  }
},


// Convert a latin-1 char to int
latin2int = function(i){
  if(i){
    J = i.charCodeAt();
    J = (6E4 < J ? 0 : 255 < J ? "€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ".indexOf(i) + 128 : J);
    return J;
  }
},

// Draw an item (point / polygon)
// and return an array containing the distance and x/y coordinates of the point that's the closest to the click coordinates (X/Y)
traceitem = function(polygon, startbyte, bytes, diststep, fill, stroke, scale, xoffset, yoffset, linewidth){
  
  //console.log(scale);
  var j, k, x, y, tmpx, tmpy, x0, y0, J, A, D, dist, ret=[0], mindist = 9999;
  
  //console.log(startbyte, bytes, diststep, fill, stroke, scale, xoffset, yoffset, linewidth);
  
  // Separate the islands of the polygon (using char U+127)
  polygon = polygon.slice(startbyte).split("");
  
  //console.log(polygon);
  
  // For each island
  for(k = 0; k < (bytes ? 1 : polygon.length); k++){
  
    //console.log("k", k, polygon[k], polygon[k].length);
    
    // For each point of the island (or the number of points specified in bytes)
    for(j = 0; j < (bytes ? bytes : polygon[k].length); j++){
    
      //console.log("j", j, polygon[k][j], latin2int(polygon[k][j]));
      
      // Begin the path with the start coordinates (X/Y, encoded in 1 char each)
      if(j == 0){
        c.beginPath();
        x0 = x = (latin2int(polygon[k][j])*diststep);
        y0 = y = (latin2int(polygon[k][j+1])*diststep/2);
        c.moveTo(tmpx = x/2 * scale + xoffset, tmpy = y/2 * scale + yoffset + 65);
        
        // Save the point if it's the closest to the click coordinates
        dist = Math.hypot(X - tmpx, Y - tmpy);
        if(dist < mindist){
          ret = [mindist = dist, tmpx, tmpy];
        }
        
        // Also, try offscreen paths (except in US)
        if(scale == 1){
          dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
          
          if(dist < mindist){
            ret = [mindist = dist, tmpx - 1020, tmpy];
          }
          
          dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
          
          if(dist < mindist){
            ret = [mindist = dist, tmpx + 1020, tmpy];
          }
        }
        
        //console.log("start", latin2int(polygon[k][j]),latin2int(polygon[k][j+1]));
        
        // Trace a little black square at the start coordinates, to make the little islands visible
        c.fillStyle = stroke;
        if(stroke && fill){
          c.fillRect(x/2 * scale + xoffset, y/2 * scale + yoffset + 65, 1, 1);
        }
        
        // Highlight (linewidth = 5) if the target is a point: circle the point in yellow
        if(linewidth == 5 && ((polygon.length == 1 && polygon[0].length < 5) || bytes == 2)){
          c.arc(x/2 * scale + xoffset, y/2 * scale + yoffset + 65, 10, 0, 7);
        }
        
        j++;
      }
      
      // Continue the path with a distance and an angle encoded together in 1 char
      else {
        J = latin2int(polygon[k][j]);
        //console.log(J);
        A = -((J>>3)-1)* Math.PI/8,
        D = (J&7)*diststep+diststep,
        x = Math.floor(x+D*Math.cos(A))
        y = Math.floor(y+D*Math.sin(A))
        c.lineTo(tmpx = x/2 * scale + xoffset, tmpy = y/2 * scale + yoffset + 65);

        // Save the center if it's the closest to the click coordinates
        dist = Math.hypot(X - tmpx, Y - tmpy);
        
        if(dist < mindist){
          ret = [mindist = dist, tmpx, tmpy];
        }
        
        // Also, try offscreen paths
        if(scale == 1){
          dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
          
          if(dist < mindist){
            ret = [mindist = dist, tmpx - 1020, tmpy];
          }
          
          dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
          
          if(dist < mindist){
            ret = [mindist = dist, tmpx + 1020, tmpy];
          }
        }
        
        
      }
      
    }
    
    // If the polygon is filled (i.e. not a stream), close the path
    if(fill){
      c.lineTo(x0/2 * scale + xoffset, y0/2 * scale + yoffset + 65);
    }
    
    // Stroke the path (0.5px wide for the streams);
    c.strokeStyle = stroke;
    c.lineWidth = linewidth == 5 ? 5 : fill ? scale > 1 ? 4 : linewidth : .5;
    //console.log(c.lineWidth)
    if(stroke){
      c.stroke();
    }
    
    // Fill the path (poles are colored in white sxept during highlight)
    if(fill){
      c.fillStyle = (linewidth != 5 && (y0 < 75 || y0 > 900)) ? "#fff" : fill;
    }
    if(fill){
      c.fill();
    }
    
    // Check if the last click was inside the polygon
    //c.closePath();
    if(c.isPointInPath(X, Y)){
      ret = [mindist = 0];
    }
  }
  
  // Adjust the error distance according to the scale
  if(ret[0]){
    ret[0] /= scale;
  }
  
  return ret;
},

tracesea = function(sea){
  //console.log(sea);
  var x, y, tmpx, tmpy, r, dist, mindist = 99999, ret;
  x = latin2int(sea[0])*16;
  y = latin2int(sea[1])*16/2;
  r = latin2int(sea[2])*16;
  c.beginPath();
  c.arc(tmpx = x/2, tmpy = y/2 + 65, r/2, 0, 7);
  c.arc(x/2-1020, y/2 + 65, r/2, 0, 7);
  c.arc(x/2+1020, y/2 + 65, r/2, 0, 7);
  
  // Save the center if it's the closest to the click coordinates
  dist = Math.hypot(X - tmpx, Y - tmpy);
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx, tmpy];
  }
  
  // Also, try offscreen seas
  dist = Math.hypot(X - (tmpx - 1020), Y - tmpy);
  
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx - 1020, tmpy];
  }
  
  dist = Math.hypot(X - (tmpx + 1020), Y - tmpy);
  
  if(dist < mindist){
    ret = [mindist = dist - r/2, tmpx + 1020, tmpy];
  }
  
  
  c.fillStyle = "yellow";
  c.fill();
  //c.closePath();
  if(c.isPointInPath(X,Y)){
    ret = [mindist = 0];
  }
  
  return ret;
},

// Draw a dataset
trace = function(ds, scale, xoffset, yoffset){

  ds = datasets[ds];
  
  // Trace each item with the right params
  for(i in ds[2]){
  
    //if(F[i] == "Loire")
    ///console.log("i", i, ds[2][i]);
    traceitem(ds[2][i], ds[7], ds[4], ds[10], ds[5], ds[6], scale, xoffset, yoffset, 2);
    //break;
  }
},

// Convert pointer coords to canvas intrinsic coords (X, Y).
xy = function(e){

  // Measure canvas size on state
  w = a.offsetWidth;
  
  // Mobile
  if(e.changedTouches){
    X = e.changedTouches[0].pageX * 1024 / w;
    Y = e.changedTouches[0].pageY * 1024 / w;
  }
  
  // Desktop
  else{
    X = e.pageX * 1024 / w;
    Y = e.pageY * 1024 / w;
  }
};
  
// EVENTS
// ======

// mousemove, touchmove
/*onmousemove = ontouchmove = function(e){
  xy(e);
  document.title = "move " + ~~X + " " + ~~Y;
};*/
  
// Mouseup, touchend
//onmouseup = ontouchend = function(e){
onclick = function(e){

  xy(e);
  
  // On title screen (0)
  if(state == 0){

    // detect OS with bad flag support (Win / Linux)
    if(/W|L/.exec(navigator.platform)){
      state = 10;
    }
    else {
      state = 1;
    }
    draw();
  }
  
  // On flags screen (10)
  else if(state == 10){
    if(X > 510){
      flags = 0;
    }
    state = 1;
    draw();
  }
  
  // On mode screen (1)
  else if(state == 1){
  
    // Least errors
    if(Y > 370) {
      questions = flags ? 1123 : 925;
      mode = 1;
      state = 2;
    }
    
    else {
      state = 11;
    }
    
    draw();
  }
  
  // On Highest score submenu (11)
  else if(state == 11){
    if(Y > 450){
      questions = 100;
    }
    else if(Y > 310){
      questions = 50;
    }
    else{
      questions = 25;
    }
    
    if(X > 500){
      questions *= 10;
    }
    
    state = 2;
    
    draw();
  }
  
  // On question screen (2)
  else if(state == 2){
    
    // Start timer
    time = new Date;
    
    // Go to map
    state = 3;
    draw();
  }
  
  // On map (3)
  else if(state == 3){
  
    // Stop timer
    time = ~~((new Date - time)/1000);
    // Go to feedback
    state = 4;
    draw();
  }
  
  // On feedback (4)
  else if(state == 4){
    question++;
    state = 2;
    draw();
  }
  
  // On score screen (5)
  else if(state == 5){
    
    if(Y < 430){
    
      // Share
      window.open("//twitter.com/home?status=" + encodeURIComponent("I played #Geoquiz2 by @maximeeuziere\n"+ (mode ? "endless mode" : "high score mode, " + questions + "questions") + "\nMy score: " + score + "!\nPlay here: " + window.location + "\n#js13k"));
    }
    
    // Reload
    location = location;
    
  }
  
};


// INIT
// ====

// Font polyfill
b.style.fontFamily = "i";

// Remove Kosovo flag, because it can't be displayed properly on many browsers, even with a Web font.
datasets[13][3].splice(102, 1);

// Draw title state
draw();

}

// MUSIC
// =====

music = function(){
audio=new AudioContext;
gain=audio.createGain();
for(note in notes=`










cccc\r
ccc










cccc
ccc


\r
ccc
c\rcc`){
oscillator=audio.createOscillator(),
oscillator.connect(gain),
gain.connect(audio.destination);
oscillator.start(note*.2);
oscillator.frequency.setValueAtTime(415*1.06**(13-notes.charCodeAt(note)),note*.2),
gain.gain.setValueAtTime(.5, note*.2); 
gain.gain.setTargetAtTime(.001, note*.2+.18,.005)
oscillator.stop(note*.2+.19);
}
}
music();
//setInterval(music, 30500);